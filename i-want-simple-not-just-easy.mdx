---
type: reaction
title: I Want Simple Not Just Easy
description: You've surely read plenty about how simple is good, but what's wrong with easy?
tags:
  - abstraction
  - clean code
lastmod: 2023-08-12
---

## Quotes

>

## Simple VS. Complex Spectrum

it describes how irregular and interconnected a system is.

Simple systems can be broken down into smaller pieces that are understandable in isolation.
If you make changes to one of those pieces, you don’t have to fear unexpected ramifications in parts not directly connected to what you’re operating on.

> javascript is an exception here

Complex systems are the exact opposite: you’ll need to keep in mind a lot of things and tread carefully.

> Simple systems are made up of smaller boxes

## Easy VS. Hard Spectrum

it describes how much energy and time it takes to successfully execute something.

Easy things generally require less preparation and can be done reliably even by inexperienced individuals.

By definition, hard stuff requires more effort and not everybody gets it right all the time.

> EASY IS BETTER THAN HARD

## It can be simple and hard at the same time, but how?

for example, suppose that you have an array containing a million different integers, and you want to sort it manually!!

the task is extremely simple, but extremely hard at the same time

## Common sense

> Complex things tend to be hard, while simple things tend to be easy, but that’s not always the case.

Software engineering can shift this balance almost alchemically, although not always for the best.

## Abstraction

Every time you build an abstraction, you encapsulate a given amount of complexity, making it easier to use.

abstracting doesn't decrease complexity, it does draw a box around a subsystem. If you remember, simple systems are made up of smaller boxes, so abstraction is a step towards composing bigger systems without increasing complexity too much. It’s also good that it made things easier

> NOT ALL ABSTRACTION MANAGES COMPLEXITY

### Abstraction benefits

- make things easier.
- hide complexity.

> We have an infinite amount of things we could learn or build and an ever-limited amount of time and energy to do it. The cheaper we can do it for, the more we can have, and the benefits compound over time.

### The rules of Abstraction

introducing abstraction has two main effects:

1. Lowers difficulty by hiding some of the details. Fewer lines to write, fewer things to keep in mind and think about — or even to right out know.
2. Identifies a cohesive subsystem and draws a box around it. The box becomes then a tool that can be reused to build bigger systems while keeping complexity down.

complexity management is not trivial. It’s easier to lower difficulty rather than constrain complexity, and that’s often what happens when development is blind to this concept: easy software that encapsulates more complexity than it should.

## Bloat

> Easy complexity

Easy complexity shows up in many places, causing all kinds of problems.

the term "bloated" is a legitimate way of describing something that fails to manage complexity in a misguided effort to make things easy.

### USING BLOATED TOOLS

The universal property of bloated tools is being resource-hungry and needlessly slow.

In the beginning, this seems almost innocuous, but as time goes on you will find that a significant percentage of human and system time gets wasted on waiting for them to perform even trivial operations.

> When you only approximately know one way of doing things, you will also be limited in the range of things you can do

> Choosing slow and unreliable tools will make you a slow, unreliable developer with a limited and quickly depreciating skill set.

> The tools you use define the shape of the person you become

but when you can understand what you’re doing, troubleshoot problems, and in general be able to iterate quickly, then you will have a real opportunity for improvement.

## What did I learn

- bloat is a friendly name for some incarnations of easy complexity
- Using bloated toolchains will have negative effects on both your productivity and personal growth.
- Slowness alone is a problem, but when combined with unreliability, it becomes devastating.
- A reliable environment is a fundamental prerequisite for building competence.
- The second most important prerequisite is a feedback loop that allows you to quickly gauge the result of your actions. The tighter the feedback loop, the better. When it takes minutes to build a project and run a fistful of tests, the loop is definitely not as tight as it should be.
- Using bloated frameworks will prevent you from understanding the details of what you’re doing and cause your software to inherit bad traits such as slowness and unreliability, further spreading the effects of easy complexity.
- New approaches will inevitably come, and if you never built an appreciation for the different trade-offs, all change will seem useless and arbitrary.
- why you can’t ignore complexity. It doesn’t matter how easy you try to make things: complexity is an almost radioactive source of difficulty.

> The value of a maker is reflected in the quality of their tools.

## Resources

- [I Want Simple, Not Just Easy](https://kristoff.it/blog/simple-not-just-easy/)
